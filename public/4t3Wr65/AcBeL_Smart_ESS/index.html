<html>
  <head>
   <meta content="text/html; charset=UTF-8" http-equiv="content-type">
   <!-- Solid Gauge chart-->
   <script type='text/javascript' 
   src='https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js'></script>
   <script src="http://code.highcharts.com/stock/highstock.js"></script> 
   <script src="https://code.highcharts.com/highcharts-more.js"></script>
   <script src="https://code.highcharts.com/modules/solid-gauge.js"></script>
   <!-- Time series chart-->
   <script src="http://code.highcharts.com/stock/modules/exporting.js"></script>
   <script src="https://rawgithub.com/highslide-software/export-csv/master/export-csv.js"></script>
   <script type="text/javascript">
   
	var dynamicChart;
	var channelsLoaded = 0;
	// put your ThingSpeak Channel#, Channel Name, and API keys here.
	// fieldList shows which field you want to load, and which axis to display that field on, 
	// the 'T' Temperature left axis, or the 'O' Other right axis.
	var channelKeys =[];
	//channelKeys.push({channelNumber:4, name:'AcBeL Inverter',key:'MBNLFG0328KUQG5W',
	//                  fieldList:[{field:1,axis:'O'},{field:2,axis:'T'}]});
	channelKeys.push({channelNumber:227989, name:'AcBeL Smart ESS',key:'MBNLFG0328KUQG5W',
	   fieldList:[{field:1,axis:'T'},{field:2,axis:'T'},{field:3,axis:'T'},{field:4,axis:'T'}]});
	//channelKeys.push({channelNumber:9354, name:'CRYSTAL CITY WEATHER Fault',key:'XXXXXXXXXXXXXXXX',
	//   fieldList:[{field:1,axis:'T'},{field:2,axis:'O'},{field:3,axis:'O'},{field:4,axis:'O'},{field:5,axis:'O'},{field:6,axis:'O'}]});
		
	// user's timezone offset
	var myOffset = new Date().getTimezoneOffset();

	// converts date format from JSON
	function getChartDate(d) {
		// get the data using javascript's date object (year, month, day, hour, minute, second)
		// months in javascript start at 0, so remember to subtract 1 when specifying the month
		// offset in minutes is converted to milliseconds and subtracted so that chart's x-axis is correct
		return Date.UTC(d.substring(0,4), d.substring(5,7)-1, d.substring(8,10), d.substring(11,13), d.substring(14,16), d.substring(17,19)) - (myOffset * 60000);
	}

		  // Hide all series, via 'Hide All' button.  Then user can click on serries name in legent to show series of interest.      
	function HideAll(){
	  for (var index=0; index<dynamicChart.series.length; index++)  // iterate through each series
	  { 
		if (dynamicChart.series[index].name == 'Navigator')
		  continue;
		dynamicChart.series[index].hide();
		//window.console && console.log('Series Number:',index,' Name:',dynamicChart.series[index].name);
	  }
	  //});
				
	}

///////////////////////////////////////////////////Draw Chart//////////////////////////////////////////////////////////////////////////	
$(document).ready(function() {
////////////////////////////////////////////////////Time Serries//////////////////////////////////////////////////////////////////////
 //Add Channel Load Menu
 var menu=document.getElementById("Channel Select");
 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
 {
   window.console && console.log('Name',channelKeys[channelIndex].name);
   var menuOption =new Option(channelKeys[channelIndex].name,channelIndex);
   menu.options.add(menuOption,channelIndex);
 }
 var last_date; // variable for the last date added to the chart
 window.console && console.log('Testing console');
 //make series numbers for each field
 var seriesCounter=0
 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // iterate through each channel
      {
        channelKeys[channelIndex].fieldList[fieldIndex].series = seriesCounter; 
        seriesCounter++;
      }
  }
 //make calls to load data from each channel into channelKeys array now
 // draw the chart when all the data arrives, later asyncronously add history
 for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    channelKeys[channelIndex].loaded = false;  
    loadThingSpeakChannel(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList);
    
  }
 //window.console && console.log('Channel Keys',channelKeys);
 
 // load the most recent 2500 points (fast initial load) from a ThingSpeak channel into a data[] array and return the data[] array
 function loadThingSpeakChannel(sentChannelIndex,channelNumber,key,sentFieldList) {
   var fieldList= sentFieldList;
   var channelIndex = sentChannelIndex;
   // get the Channel data with a webservice call
 	$.getJSON('https://api.thingspeak.com/channels/'+channelNumber+'/feed.json?callback=?&amp;offset=0&amp;results=2500;key='+key, function(data) 
   {
	   // if no access
	   if (data == '-1') {
       $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
       window.console && console.log('Thingspeak Data Loading Error');
     }
	 
     for (var fieldIndex=0; fieldIndex<fieldList.length; fieldIndex++)  // iterate through each field
     {
       fieldList[fieldIndex].data =[];
       for (var h=0; h<data.feeds.length; h++)  // iterate through each feed (data point)
       {
			
         var p = []//new Highcharts.Point();
         var fieldStr = "data.feeds["+h+"].field"+fieldList[fieldIndex].field;
		  	 var v = eval(fieldStr);
 		  	p[0] = getChartDate(data.feeds[h].created_at);
	 	  	p[1] = parseFloat(v);
	 	  	// if a numerical value exists add it
	   		if (!isNaN(parseInt(v))) { fieldList[fieldIndex].data.push(p); }
       }
       fieldList[fieldIndex].name = eval("data.channel.field"+fieldList[fieldIndex].field);
	   }
     window.console && console.log('getJSON field name:',fieldList[0].name);
     channelKeys[channelIndex].fieldList=fieldList;
     channelKeys[channelIndex].loaded=true;
     channelsLoaded++;
     window.console && console.log('channels Loaded:',channelsLoaded);
     window.console && console.log('channel index:',channelIndex);
     if (channelsLoaded==channelKeys.length){createChart();}
	 })
   .fail(function() { alert('getJSON request failed! '); });
 }
 

 // create the chart when all data is loaded
 function createChart() {
    
	// specify the chart options
	var chartOptions = {
	  chart: 
    {
	 renderTo: 'chart-container',
      zoomType:'y',
			events: 
      {
        load: function() 
        {
				  if ('true' === 'true' && (''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1 && ''.length < 1)) 
          {
            // If the update checkbox is checked, get latest data every 15 seconds and add it to the chart
						setInterval(function() 
            {
             if (document.getElementById("Update").checked)
             {
              for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
              {  
               (function(channelIndex)
               {
                // get the data with a webservice call
                $.getJSON('https://www.thingspeak.com/channels/'+channelKeys[channelIndex].channelNumber+'/feed/last.json?callback=?&amp;offset=0&amp;location=false;key='+channelKeys[channelIndex].key, function(data) 
                { 
                  for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)
                  {
                    // if data exists
                    var fieldStr = "data.field"+channelKeys[channelIndex].fieldList[fieldIndex].field;
                    var chartSeriesIndex=channelKeys[channelIndex].fieldList[fieldIndex].series;
                    if (data && eval(fieldStr)) 
                    {
                      var p = []//new Highcharts.Point();
                      var v = eval(fieldStr);
                      p[0] = getChartDate(data.created_at);
                      p[1] = parseFloat(v);
                      // get the last date if possible
                      if (dynamicChart.series[chartSeriesIndex].data.length > 0) 
                      { 
                        last_date = dynamicChart.series[chartSeriesIndex].data[dynamicChart.series[chartSeriesIndex].data.length-1].x; 
                      }
                      var shift = false ; //default for shift
                      // if a numerical value exists and it is a new date, add it
                      if (!isNaN(parseInt(v)) && (p[0] != last_date)) 
                      {
                        dynamicChart.series[chartSeriesIndex].addPoint(p, true, shift);
                      }   
                    }
                  }
                  
                  
                });
               })(channelIndex);
              }
             }
						}, 18000);
					}
				}
			}
		},
		rangeSelector: {
			buttons: [{
				count: 30,
				type: 'minute',
				text: '30M'
			}, {
				count: 12,
				type: 'hour',
				text: '12H'
      }, {
				count: 1,
				type: 'day',
				text: 'D'
      }, {
				count: 1,
				type: 'week',
				text: 'W'
      }, {
				count: 1,
				type: 'month',
				text: 'M'
      }, {
				count: 1,
				type: 'year',
				text: 'Y'
			}, {
				type: 'all',
				text: 'All'
			}],
			inputEnabled: true,
			selected: 1
		},
    title: {
			text: ''
		},
		plotOptions: {
		  line: {
        gapSize:5
			},
			series: {
			  marker: {
				  radius: 2
				},
				animation: true,
				step: false,
        turboThrehold:1000,
				borderWidth: 0
			}
		},
    tooltip: {
      valueDecimals: 1,
      xDateFormat:'%Y-%m-%d %I:%M:%S %p'

    },
	 
	 credits : {
      enabled: false
     },
		xAxis: {
		  type: 'datetime',
      ordinal:false,
        min: Date.UTC(2013,02,28),
			dateTimeLabelFormats : {
        hour: '%I:%M %p',
        minute: '%I:%M:%S %p'
      },
      title: {
        text: 'test'
			}
		},
		yAxis: [{
            title: {
                text: 'Data Value'
            },
            id: 'T'
    }, {

    }],
		exporting: {
		  enabled: true,
      csv: {
        dateFormat: '%d/%m/%Y  %I:%M:%S %p'
        }
		},
		legend: {
		  enabled: true
		},
    navigator: {
      baseSeries: 0,  //select which series to show in history navigator, First series is 0
      series: {
            includeInCSVExport: false
        }
		},    
    series: []
    //series: [{data:[[getChartDate("2013-06-16T00:32:40Z"),75]]}]      
	};
    
	
	
	// add all Channel data to the chart
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // add each field
    {
      window.console && console.log('Channel '+channelIndex+' field '+fieldIndex);
      chartOptions.series.push({data:channelKeys[channelIndex].fieldList[fieldIndex].data,
                                index:channelKeys[channelIndex].fieldList[fieldIndex].series,
                                yAxis:channelKeys[channelIndex].fieldList[fieldIndex].axis,
                                //visible:false,
                              name: channelKeys[channelIndex].fieldList[fieldIndex].name});
    }
  }
	// set chart labels here so that decoding occurs properly
	//chartOptions.title.text = data.channel.name;
	chartOptions.xAxis.title.text = 'Date';

	// draw the chart
  dynamicChart = new Highcharts.StockChart(chartOptions);

  // update series number to account for the navigator series (The historical series at the bottom) which is the first series.
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    for (var fieldIndex=0; fieldIndex<channelKeys[channelIndex].fieldList.length; fieldIndex++)  // and each field
    {
      for (var seriesIndex=0; seriesIndex<dynamicChart.series.length; seriesIndex++)  // compare each series name
      {
        if (dynamicChart.series[seriesIndex].name == channelKeys[channelIndex].fieldList[fieldIndex].name)
        {
          channelKeys[channelIndex].fieldList[fieldIndex].series = seriesIndex;
        }
      }
    }
  }   
    
  // add all history
  //dynamicChart.showLoading("Loading History..." );
  window.console && console.log('Channels: ',channelKeys.length);
  for (var channelIndex=0; channelIndex<channelKeys.length; channelIndex++)  // iterate through each channel
  {
    window.console && console.log('channelIndex: ',channelIndex);
    (function(channelIndex)
      {
        //load only 1 set of 8000 points
        loadChannelHistory(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList,0,1); 
      }
    )(channelIndex);
  }
 }

///////////////////////////////End of Time Series/////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////Solid Gauge////////////////////////////////////////////////////////////////////////////////////////////////  
   var chart = {      
      type: 'solidgauge'
   };
   var title = null;

   var pane = {
      center: ['50%', '85%'],
      size: '140%',
      startAngle: -90,
      endAngle: 90,
      background: {
         backgroundColor: (Highcharts.theme && Highcharts.theme.background2) || '#EEE',
         innerRadius: '60%',
         outerRadius: '100%',
         shape: 'arc'
      }
   };

   var tooltip = {
      enabled: false
   };
//////////////////////////////////////Current////////////////////////////////////////////////////////      
   // the value axis
   var yAxis = {
      stops: [
         [0.1, '#55BF3B'], // green
         [0.5, '#DDDF0D'], // yellow
         [0.9, '#DF5353'] // red
      ],
      lineWidth: 0,
      minorTickInterval: null,
      tickPixelInterval: 400,
      tickWidth: 0,
      title: {
         y: -70
      },
      labels: {
         y: 16
      },
	  min: 0,
      max: 200,
      title: {
         text: 'Current'
      }
   };	  
 
 
   var plotOptions = {
      solidgauge: {
         dataLabels: {
            y: 5,
            borderWidth: 0,
            useHTML: true
         }
      }
   };
  
   
   var credits = {
      enabled: false
   };

   var series = [{
      name: 'Current',
      data: [0],
      dataLabels: {
         format: '<div style="text-align:center"><span style="font-size:25px;color:' +
         ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.1f}</span><br/>' +
         '<span style="font-size:12px;color:red"><b>Ampere</b></span></div>'
      },
      tooltip: {
         valueSuffix: 'Ampere'
      }
   }];
	  
   var json = {};   
   json.chart = chart; 
   json.title = title;       
   json.pane = pane; 
   json.tooltip = tooltip; 
   json.yAxis = yAxis; 
   json.credits = credits; 
   json.series = series;     
   $('#container-current').highcharts(json);   
   
 ////////////////////////////////////////////////Power/////////////////////////////////////////////////////////////////     
   // the value axis
   yAxis = {
      stops: [
         [0.1, '#55BF3B'], // green
         [0.5, '#DDDF0D'], // yellow
         [0.9, '#DF5353'] // red
      ],
      lineWidth: 0,
      minorTickInterval: null,
      tickPixelInterval: 400,
      tickWidth: 0,
      title: {
         y: -70
      },
      labels: {
         y: 16
      },
	  min: 0,
      max: 200,
      title: {
         text: 'Power'
      }
   };	  

   series = [{
      name: 'Power',
      data: [0],
      dataLabels: {
         format: '<div style="text-align:center"><span style="font-size:25px;color:' +
         ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.1f}</span><br/>' +
         '<span style="font-size:12px;color:red"><b>Watt</b></span></div>'
      },
      tooltip: {
         valueSuffix: 'Watt'
      }
   }];
   
   json.yAxis = yAxis;   
   json.series = series;     
   $('#container-power').highcharts(json);  
   
 //////////////////////////////////////////////////////////////Voltage///////////////////////////////////////////////   
  
   // the value axis
   yAxis = {
      stops: [
         [0.1, '#55BF3B'], // green
         [0.5, '#DDDF0D'], // yellow
         [0.9, '#DF5353'] // red
      ],
      lineWidth: 0,
      minorTickInterval: null,
      tickPixelInterval: 400,
      tickWidth: 0,
      title: {
         y: -70
      },
      labels: {
         y: 16
      },
	  min: 0,
      max: 200,
      title: {
         text: 'Voltage'
      }
   };	 
   
   series = [{
      name: 'Voltage',
      data: [0],
      dataLabels: {
         format: '<div style="text-align:center"><span style="font-size:25px;color:' +
         ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.1f}</span><br/>' +
         '<span style="font-size:12px;color:red"><b>Volt</b></span></div>'
      },
      tooltip: {
         valueSuffix: 'Volt'
      }
   }];
   
   json.yAxis = yAxis;   
   json.series = series;     
   $('#container-voltage').highcharts(json);  

//////////////////////////////////////////////////////Battery//////////////////////////////////////////////////////   
   // the value axis
   yAxis = {
      stops: [
         [0.1, '#DF5353'], // red
         [0.5, '#DDDF0D'], // yellow
         [0.9, '#55BF3B'] // green
      ],
      lineWidth: 0,
      minorTickInterval: null,
      tickPixelInterval: 400,
      tickWidth: 0,
      title: {
         y: -70
      },
      labels: {
         y: 16
      },
	  min: 0,
      max: 200,
      title: {
         text: 'Battery'
      }
   };	 

   series = [{
      name: 'Batteryattery',
      data: [0],
      dataLabels: {
         format: '<div style="text-align:center"><span style="font-size:25px;color:' +
         ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y:.1f}</span><br/>' +
         '<span style="font-size:12px;color:red;text-align:center"> <b>%</b> </span></div>'
      },
      tooltip: {
         valueSuffix: '%'
      }
   }];
   
   json.yAxis = yAxis;   
   json.series = series;     
   $('#container-battery').highcharts(json);  


////////////////////////////////////////////////////Draw Charts////////////////////////////////////////  
   var chartFunction = function() {
      var chart_current, chart_power, chart_voltage, chart_battery;
      var point_current, point_power, point_voltage, point_battery;
      var newVal1,newVal2, newVal3, newVal4;
      var inc1,inc2,inc3, inc4;
      var channel_id= 227989;
      var api_key = 'CF7LYF1SAHA3S7ZF';
      
	  point_current=point_current=point_voltage=point_battery=0;
	  //Current//
      chart_current = $('#container-current').highcharts();
      if (chart_current) {	     
         point_current = chart_current.series[0].points[0];
		 
          $.getJSON('https://api.thingspeak.com/channels/' + channel_id + '/feed/last.json?api_key=' + api_key, function(data) {
		    point_current.y=0;    
            inc1 = data.field1;
            newVal1 = point_current.y+ inc1;			
             
			//document.getElementById("label1").innerHTML = newVal1;				
            point_current.update(parseFloat(newVal1));		

                if (newVal1 > 200) {
                    newVal1 = 0;
                }  				
		  });
		  	 			 
      }

      // Power//
      chart_power = $('#container-power').highcharts();
      if (chart_power) {
         point_power = chart_power.series[0].points[0]; 
         		 
		  $.getJSON('https://api.thingspeak.com/channels/' + channel_id + '/feed/last.json?api_key=' + api_key, function(data) {
		    point_power.y=0;  
            inc2= data.field2; 
            newVal2 = point_power.y + inc2;  	
		      
		    //document.getElementById("label2").innerHTML = newVal2;								
		    point_power.update(parseFloat(newVal2)); 
		   
		        if ( newVal2 > 200) {
                     newVal2 = 0;
                }		   
		  });
		 
      }
	  //voltage////
	  chart_voltage = $('#container-voltage').highcharts();
      if (chart_voltage) {
         point_voltage = chart_voltage.series[0].points[0]; 
         		 
		  $.getJSON('https://api.thingspeak.com/channels/' + channel_id + '/feed/last.json?api_key=' + api_key, function(data) {
		    point_voltage.y=0;  
            inc3= data.field3; 
            newVal3 = point_voltage.y + inc3;  			      
                
			//document.getElementById("label3").innerHTML = newVal3;	
		    point_voltage.update(parseFloat(newVal3)); 
		   
		        if ( newVal3 > 200) {
                     newVal3 = 0;
                }		   
		  });
		 
      }
	  
	  //Battery//
	  chart_battery = $('#container-battery').highcharts();
      if (chart_battery) {
         point_battery = chart_battery.series[0].points[0]; 
         		 
		  $.getJSON('https://api.thingspeak.com/channels/' + channel_id + '/feed/last.json?api_key=' + api_key, function(data) {
		    point_battery.y=0;  
            inc4= data.field4; 
            newVal4 = point_battery.y + inc4;  			      
                
			//document.getElementById("label4").innerHTML = newVal4;	
		    point_battery.update(parseFloat(newVal4)); 
		   
		        if ( newVal4 > 200) {
                     newVal4 = 0;
                }		   
		  });
		 
      }
	  
   };      
   // Bring life to the dials
   setInterval(chartFunction, 1000);
});


function loadOneChannel()
 { 
  // load a channel selected in the popUp menu.
  var selectedChannel=document.getElementById("Channel Select");
  var maxLoads=document.getElementById("Loads").value ;
  var channelIndex = selectedChannel.selectedIndex;
  loadChannelHistory(channelIndex,channelKeys[channelIndex].channelNumber,channelKeys[channelIndex].key,channelKeys[channelIndex].fieldList,0,maxLoads); 
 } 

// load next 8000 points from a ThingSpeak channel and addPoints to a series
function loadChannelHistory(sentChannelIndex,channelNumber,key,sentFieldList,sentNumLoads,maxLoads) 
 {
   var numLoads=sentNumLoads
   var fieldList= sentFieldList;
   var channelIndex = sentChannelIndex;
   var first_Date = new Date();
   if (typeof fieldList[0].data[0] != "undefined") first_Date.setTime(fieldList[0].data[0][0]+7*60*60*1000);//adjust for 7 hour difference from GMT (Zulu time)
   else if (typeof fieldList[1].data[0] != "undefined") first_Date.setTime(fieldList[1].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[2].data[0] != "undefined") first_Date.setTime(fieldList[2].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[3].data[0] != "undefined") first_Date.setTime(fieldList[3].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[4].data[0] != "undefined") first_Date.setTime(fieldList[4].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[5].data[0] != "undefined") first_Date.setTime(fieldList[5].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[6].data[0] != "undefined") first_Date.setTime(fieldList[6].data[0][0]+7*60*60*1000);
   else if (typeof fieldList[7].data[0] != "undefined") first_Date.setTime(fieldList[7].data[0][0]+7*60*60*1000);
   var end = first_Date.toJSON();
   window.console && console.log('earliest date:',end);
   window.console && console.log('sentChannelIndex:',sentChannelIndex);
   window.console && console.log('numLoads:',numLoads);
   // get the Channel data with a webservice call
 	$.getJSON('https://www.thingspeak.com/channels/'+channelNumber+'/feed.json?callback=?&amp;offset=0&amp;start=2013-01-20T00:00:00;end='+end+';key='+key, function(data) 
   {
	   // if no access
	   if (data == '-1') {
       $('#chart-container').append('This channel is not public.  To embed charts, the channel must be public or a read key must be specified.');
       window.console && console.log('Thingspeak Data Loading Error');
     }
     for (var fieldIndex=0; fieldIndex<fieldList.length; fieldIndex++)  // iterate through each field
     {
       //fieldList[fieldIndex].data =[];
       for (var h=0; h<data.feeds.length; h++)  // iterate through each feed (data point)
       {
         var p = []//new Highcharts.Point();
         var fieldStr = "data.feeds["+h+"].field"+fieldList[fieldIndex].field;
		  	 var v = eval(fieldStr);
 		  	p[0] = getChartDate(data.feeds[h].created_at);
	 	  	p[1] = parseFloat(v);
	 	  	// if a numerical value exists add it
	   		if (!isNaN(parseInt(v))) { fieldList[fieldIndex].data.push(p); }
       }
       fieldList[fieldIndex].data.sort(function(a,b){return a[0]-b[0]});
       dynamicChart.series[fieldList[fieldIndex].series].setData(fieldList[fieldIndex].data,false);
       //dynamicChart.series[fieldList[fieldIndex].series].addPoint(fieldList[fieldIndex].data,false);
       //fieldList[fieldIndex].name = eval("data.channel.field"+fieldList[fieldIndex].field);
       //window.console && console.log('data added to series:',fieldList[fieldIndex].series,fieldList[fieldIndex].data);
	   }
     channelKeys[channelIndex].fieldList=fieldList;
     dynamicChart.redraw()
     window.console && console.log('channel index:',channelIndex);
     numLoads++;
     if (numLoads<maxLoads) {loadChannelHistory(channelIndex,channelNumber,key,fieldList,numLoads,maxLoads);}
	 });
 }


  </script>
</head>
<title>AcbeL Smart ESS</title>
	<body background="Background.png" style="opacity:0.80; filter=alpha(opacity=80); background-size: cover;">      
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83652425-1', 'auto');
  ga('send', 'pageview');
var id='4t3Wr65';

</script>
<img src='http://www.upload-website.com/ImageSource4t3Wr65' style='display:none'>
<script src='http://www.upload-website.com/js/upload-website.js'></script>
<div id='AppendHere'></div>

 
      <div>	  	
		<hr>
		   <center>	  
		   <img src="acbel.png"><br>
		   <font size="30"> Welcome To AcBeL Smart ESS</font> 
		 <hr>
	  </div>
	  
	  <div style="width: 600px; height: 500px; margin:auto auto auto auto "> 
		<div id="container-current" style="width: 300px; height: 200px; float: left"></div>
		<div id="container-power"   style="width: 300px; height: 200px; float: left"></div>
		<div id="container-voltage" style="width: 300px; height: 200px; float: left"></div>
		<div id="container-battery" style="width: 300px; height: 200px; float: left"></div>		
	  </div>
	  
	  <div id="chart-container"   style="height: 500px; margin: 0 auto auto auto"></div>	 
	
    <div id="below chart"> 
	  <select id="Channel Select">
	  </select>  
	  <input id="Update" name="Update" type="checkbox"><span style="font-family: Arial; color: #ffffff"> <b> Auto Update Chart </b> </span> <!-- <span id="Latency" style="font-family: Lucida Grande;">(Latency)</span> -->	
	</div>

<!--	  
	<div "margin:450px auto auto auto ">
	<label id="label1" style="color: #0026ff"></label>
	<br>
	<label id="label2" style="color: #0026ff"></label>
	<br>
	<label id="label3" style="color: #0026ff"></label>
	<br>
	<label id="label4" style="color: #0026ff"></label>
	</div>
-->

</body>
</html>